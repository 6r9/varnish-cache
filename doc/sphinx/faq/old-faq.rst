%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The old Trac FAQ, still to be reformattet:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

::



        === Does Varnish require the system to have a C compiler? ===

        Yes.  The VCL compiler generates C source as output, and uses the systems C-compiler to compile that into a shared library.  If there is no C compiler, Varnish will not work.

        === ... Isn't that security problem? ===

        The days when you could prevent people from running non-approved programs by removing the C compiler from your system ended roughly with the VAX 11/780 computer.

        === Should I use ''pipe'' or ''pass'' in my VCL code? What is the difference? ===

        When varnish does a ''pass'' it acts like a normal HTTP proxy. It
        reads the request and pushes it onto the backend. The next HTTP
        request can then be handled like any other.

        ''pipe'' is only used when Varnish for some reason can't handle the
        ''pass''. ''pipe'' reads the request, pushes in onty the backend
        _only_ pushes bytes back and forth, with no other actions taken.

        Since most HTTP clients do pipeline several requests into one
        connection this might give you an undesirable result - as every
        subsequent request will reuse the existing ''pipe''.

        Varnish versions prior to 2.0 does not support handling a request body
        with ''pass'' mode, so in those releases ''pipe'' is required for
        correct handling.

        In 2.0 and later, ''pass'' will handle the request body correctly.

        If you get 503 errors when making a request which is ''pass''ed, make sure
        that you're specifying the backend before returning from vcl_recv with ''pass''.


        === Are regular expressions case sensitive or not? Can I change it? ===

        In 2.1 and newer, regular expressions are case sensitive by default.  In earlier versions, they were case insensitive.

        To change this for a single regex in 2.1, use "(?i)" at the start.  See the [http://www.pcre.org/pcre.txt PCRE man pages] for more information.

        == How do I... ==

        === How can I force a refresh on a object cached by varnish? ===

        Refreshing is often called [http://dictionary.reference.com/browse/PURGE purging] a document.  You can purge at least 2 different ways in Varnish:

        1. From the command line you can write:

        {{{
        url.purge ^/$
        }}}

        to purge your '''/''' document.  As you might see url.purge takes an
        [http://en.wikipedia.org/wiki/Regular_expression regular expression]
        as its argument. Hence the !^ and $ at the front and end.  If the !^ is ommited, all the documents ending in a / in the cache would be deleted.

        So to delete all the documents in the cache, write:

        {{{
        url.purge .*
        }}}

        at the command line.

        2. HTTP PURGE

        VCL code to allow HTTP PURGE [wiki:VCLExamples is to be found here]. Note that this method does not support wildcard purging.

        === How can I debug the requests of a single client? ===

        The "varnishlog" utility may produce a horrendous amount of output.  To be able debug our own traffic can be useful.

        The ReqStart token will include the client IP address.  To see log entries matching this, type:

        {{{
        $ varnishlog -c -o ReqStart 192.0.2.123
        }}}

        To see the backend requests generated by a client IP address, we can match on the TxHeader token, since the IP address of the client is included in the X-Forwarded-For header in the request sent to the backend.

        At the shell command line, type:
        {{{
        $ varnishlog -b -o TxHeader 192.0.2.123
        }}}

        === How can I rewrite URLS before they are sent to the backend? ===

        You can use the "regsub()" function to do this.  Here's an example for zope, to rewrite URL's for the virtualhostmonster:

        {{{
        if (req.http.host ~ "^(www.)?example.com") {
          set req.url = regsub(req.url, "^", "/VirtualHostBase/http/example.com:80/Sites/example.com/VirtualHostRoot");
        }

        }}}

        === I have a site with many hostnames, how do I keep them from multiplying the cache? ===

        You can do this by normalizing the "Host" header for all your hostnames.  Here's a VCL example:

        {{{
        if (req.http.host ~ "^(www.)?example.com") {
          set req.http.host = "example.com";
        }
        }}}


        === How do I do to alter the request going to the backend? ===
        You can use the ''bereq'' object for altering requests going to the backend but from my experience you can only 'set' values to it.
        So, if you need to change the requested URL, '''this doesn't work''':

        {{{
        sub vcl_miss {
                set bereq.url = regsub(bereq.url,"stream/","/");
                fetch;
        }
        }}}

        Because you cannot read from bereq.url (in the value part of the assignment). You will get:
        {{{
        mgt_run_cc(): failed to load compiled VCL program:
          ./vcl.1P9zoqAU.o: undefined symbol: VRT_r_bereq_url
        VCL compilation failed
        }}}

        Instead, you have to use '''req.url''':

        {{{
        sub vcl_miss {
                set bereq.url = regsub(req.url,"stream/","/");
                fetch;
        }
        }}}

        === How do I force the backend to send Vary headers? ===

        We have anectdotal evidence of non-RFC2616 compliant backends, which support content negotiation, but which do not emit a Vary header, unless the request contains Accept headers.

        It may be appropriate to send no-op Accept headers to trick the backend into sending us the Vary header.

        The following should be sufficient for most cases:

        {{{
        Accept: */*
        Accept-Language: *
        Accept-Charset: *
        Accept-Encoding: identity
        }}}

        Note that Accept-Encoding can not be set to *, as the backend might then send back a compressed response which the client would be unable to process.

        This can of course be implemented in VCL.

        === How can I customize the error messages that Varnish returns? ===

        A custom error page can be generated by adding a vcl_error to your configuration file. The default error page looks like this:

        {{{
        sub vcl_error {
            set obj.http.Content-Type = "text/html; charset=utf-8";

            synthetic {"
            <?xml version="1.0" encoding="utf-8"?>
            <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
             "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
            <html>
              <head>
                <title>"} obj.status " " obj.response {"</title>
              </head>
              <body>
              <h1>Error "} obj.status " " obj.response {"</h1>
              <p>"} obj.response {"</p>
                <h3>Guru Meditation:</h3>
                <p>XID: "} req.xid {"</p>
                <address><a href="http://www.varnish-cache.org/">Varnish</a></address>
              </body>
             </html>
             "};
            deliver;
        }
        }}}

        === How do I instruct varnish to ignore the query parameters and only cache one instance of an object? ===

        This can be achieved by removing the query parameters using a regexp:

        {{{
        sub vcl_recv {
            set req.url = regsub(req.url, "\?.*", "");
        }
        }}}

        === Do you have any examples? ===

        Many varnish users have contributed [wiki:VCLExamples examples] from their VCLs to solve common problems. A ready made recipe to address your question may be included.

        == Troubleshooting ==

        === Why does it look like Varnish sends all requests to the backend? I thought it was a cache? ===

        There are 2 common reasons for this:
         1. The object's '''ttl expired'''. A common situation is that the backend does not set an expiry time on the requested image/file/webpage, so Varnish uses the default TTL (normally 120s).
         2. Your site uses '''cookies''':
            * By default, varnish will not cache ''responses'' from the backend that come with a '''Set-Cookie''': header.
            * By default, varnish will not serve ''requests'' with a '''Cookie:''' header, but pass them to the backend instead. Check out [wiki:VCLExamples these VCL examples] on how to make varnish cache cookied/logged in users sanely.

        === Why am I getting a cache hit, but a request is still going to my backend? ===

        Varnish has a feature called ''hit for pass'', which is used when Varnish gets a response from the backend and finds out it cannot be cached. In such cases, Varnish will create a cache object that records that fact, so that the next request goes directly to "pass".
        See the entry above for common cases where a backend returns a non-cacheable object. See this [wiki:VCLExampleDefault graphical overview] of how the Varnish request cycle works.

        Since Varnish bundles multiple requests for the same URL to the backend, a common case where a client will get a ''hit for pass'' is:
          * Client 1 requests url /foo
            * Client 2..N request url /foo
          * Varnish tasks a worker to fetch /foo for Client 1
            * Client 2..N are now queued pending response from the worker
          * Worker returns object to varnish which turns out to be non-cacheable.
            * Client 2..N are now given the ''hit for pass'' object instructing them to go to the backend

        The ''hit for pass'' object will stay cached for the duration of it's ttl. This means that subsequent clients requesting /foo will be sent straight to the backend as long as the ''hit for pass'' object exists.
        The [wiki:StatsExplained varnishstat program] can tell you how many ''hit for pass'' objects varnish has served. You can lower the ttl for such an object if '''you are sure this is needed''', using the following logic:

        {{{
        sub vcl_fetch {
          if (!obj.cacheable) {
            # Limit the lifetime of all 'hit for pass' objects to 10 seconds
            obj.ttl = 10s;
            pass;
          }
        }

        }}}

