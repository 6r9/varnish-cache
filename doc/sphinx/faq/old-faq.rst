%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The old Trac FAQ, still to be reformattet:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

::



        == How do I... ==

        === How can I rewrite URLS before they are sent to the backend? ===

        You can use the "regsub()" function to do this.  Here's an example for zope, to rewrite URL's for the virtualhostmonster:

        {{{
        if (req.http.host ~ "^(www.)?example.com") {
          set req.url = regsub(req.url, "^", "/VirtualHostBase/http/example.com:80/Sites/example.com/VirtualHostRoot");
        }

        }}}

        === I have a site with many hostnames, how do I keep them from multiplying the cache? ===

        You can do this by normalizing the "Host" header for all your hostnames.  Here's a VCL example:

        {{{
        if (req.http.host ~ "^(www.)?example.com") {
          set req.http.host = "example.com";
        }
        }}}


        === How do I do to alter the request going to the backend? ===
        You can use the ''bereq'' object for altering requests going to the backend but from my experience you can only 'set' values to it.
        So, if you need to change the requested URL, '''this doesn't work''':

        {{{
        sub vcl_miss {
                set bereq.url = regsub(bereq.url,"stream/","/");
                fetch;
        }
        }}}

        Because you cannot read from bereq.url (in the value part of the assignment). You will get:
        {{{
        mgt_run_cc(): failed to load compiled VCL program:
          ./vcl.1P9zoqAU.o: undefined symbol: VRT_r_bereq_url
        VCL compilation failed
        }}}

        Instead, you have to use '''req.url''':

        {{{
        sub vcl_miss {
                set bereq.url = regsub(req.url,"stream/","/");
                fetch;
        }
        }}}

        === How do I force the backend to send Vary headers? ===

        We have anectdotal evidence of non-RFC2616 compliant backends, which support content negotiation, but which do not emit a Vary header, unless the request contains Accept headers.

        It may be appropriate to send no-op Accept headers to trick the backend into sending us the Vary header.

        The following should be sufficient for most cases:

        {{{
        Accept: */*
        Accept-Language: *
        Accept-Charset: *
        Accept-Encoding: identity
        }}}

        Note that Accept-Encoding can not be set to *, as the backend might then send back a compressed response which the client would be unable to process.

        This can of course be implemented in VCL.

        === How can I customize the error messages that Varnish returns? ===

        A custom error page can be generated by adding a vcl_error to your configuration file. The default error page looks like this:

        {{{
        sub vcl_error {
            set obj.http.Content-Type = "text/html; charset=utf-8";

            synthetic {"
            <?xml version="1.0" encoding="utf-8"?>
            <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
             "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
            <html>
              <head>
                <title>"} obj.status " " obj.response {"</title>
              </head>
              <body>
              <h1>Error "} obj.status " " obj.response {"</h1>
              <p>"} obj.response {"</p>
                <h3>Guru Meditation:</h3>
                <p>XID: "} req.xid {"</p>
                <address><a href="http://www.varnish-cache.org/">Varnish</a></address>
              </body>
             </html>
             "};
            deliver;
        }
        }}}

        === How do I instruct varnish to ignore the query parameters and only cache one instance of an object? ===

        This can be achieved by removing the query parameters using a regexp:

        {{{
        sub vcl_recv {
            set req.url = regsub(req.url, "\?.*", "");
        }
        }}}

        === Do you have any examples? ===

        Many varnish users have contributed [wiki:VCLExamples examples] from their VCLs to solve common problems. A ready made recipe to address your question may be included.

        == Troubleshooting ==

        === Why does it look like Varnish sends all requests to the backend? I thought it was a cache? ===

        There are 2 common reasons for this:
         1. The object's '''ttl expired'''. A common situation is that the backend does not set an expiry time on the requested image/file/webpage, so Varnish uses the default TTL (normally 120s).
         2. Your site uses '''cookies''':
            * By default, varnish will not cache ''responses'' from the backend that come with a '''Set-Cookie''': header.
            * By default, varnish will not serve ''requests'' with a '''Cookie:''' header, but pass them to the backend instead. Check out [wiki:VCLExamples these VCL examples] on how to make varnish cache cookied/logged in users sanely.

        === Why am I getting a cache hit, but a request is still going to my backend? ===

        Varnish has a feature called ''hit for pass'', which is used when Varnish gets a response from the backend and finds out it cannot be cached. In such cases, Varnish will create a cache object that records that fact, so that the next request goes directly to "pass".
        See the entry above for common cases where a backend returns a non-cacheable object. See this [wiki:VCLExampleDefault graphical overview] of how the Varnish request cycle works.

        Since Varnish bundles multiple requests for the same URL to the backend, a common case where a client will get a ''hit for pass'' is:
          * Client 1 requests url /foo
            * Client 2..N request url /foo
          * Varnish tasks a worker to fetch /foo for Client 1
            * Client 2..N are now queued pending response from the worker
          * Worker returns object to varnish which turns out to be non-cacheable.
            * Client 2..N are now given the ''hit for pass'' object instructing them to go to the backend

        The ''hit for pass'' object will stay cached for the duration of it's ttl. This means that subsequent clients requesting /foo will be sent straight to the backend as long as the ''hit for pass'' object exists.
        The [wiki:StatsExplained varnishstat program] can tell you how many ''hit for pass'' objects varnish has served. You can lower the ttl for such an object if '''you are sure this is needed''', using the following logic:

        {{{
        sub vcl_fetch {
          if (!obj.cacheable) {
            # Limit the lifetime of all 'hit for pass' objects to 10 seconds
            obj.ttl = 10s;
            pass;
          }
        }

        }}}

